#! /usr/bin/lua

-- libs
local crypto = require( "crypto" )
local lfs = require( "lfs" )
local json = require( "cjson.safe" )

-- config
local Cipher = "aes-256-ctr"
local Hash = "sha256"
local HMAC = "sha256"

local KeyLength = 32
local IVLength = 16
local HMACLength = 32

local SplitCipherTextPattern = "^(" .. string.rep( ".", IVLength ) .. ")(.+)(" .. string.rep( ".", HMACLength ) .. ")$"

-- consts
local Help =
	"Usage: " .. arg[ 0 ] .. " <command>\n"
	.. "where <command> is one of the following:\n"
	.. "\n"
	.. "genkey        - generate a private key for encrypting your passwords\n"
	.. "init          - creates an initial empty database\n"
	.. "add <name>    - prompts you to enter a password for <name>\n"
	.. "get <name>    - prints the password stored under <name>\n"
	.. "delete <name> - deleted the password stored under <name>\n"
	.. "list          - lists the names of all stored passwords\n"
	.. "touch         - decrypts, sanity checks and reencrypts the database\n"
	.. "gen <name> [length] [pattern] - generates a password for <name>. [pattern] is a Lua pattern\n"
	.. "  examples:\n"
	.. "    gen test       - 32 characters, alphanumeric/puntuation/spaces\n"
	.. "    gen test 16    - 16 characters, alphanumeric/puntuation/spaces\n"
	.. "    gen test 10 %%d - 10 characters, numbers only\n"
	.. "    gen test \"%%l \" - 32 characters, lowercase/spaces\n"

local commands = { "genkey", "init", "add", "get", "delete", "list", "touch", "gen" }

for _, command in ipairs( commands ) do
	commands[ command ] = true
end

local dir = os.getenv( "HOME" ) .. "/.pdb/"
local paths = { db = dir .. "db", key = dir .. "key" }

local random = assert( io.open( "/dev/random", "r" ) )
local urandom = assert( io.open( "/dev/urandom", "r" ) )

-- we might need this later
local passwordToAdd

-- some helpers
local function check( condition, form, ... )
	if not condition then
		io.stdout:write( form:format( ... ) .. "\n" )

		os.exit( 1 )
	end
end

local function loadKey()
	local file = assert( io.open( paths.key, "r" ) )

	local key = file:read( "*all" )
	assert( key:len() == KeyLength, "bad key file" )

	assert( file:close() )

	return key
end

local function loadDB( key )
	local file = assert( io.open( paths.db, "r" ) )

	local contents = assert( file:read( "*all" ) )
	assert( file:close() )

	local iv, c, hmac = contents:match( SplitCipherTextPattern ) 
	assert( iv, "Corrupt DB" )

	local key2 = crypto.digest( Hash, key )
	assert( hmac == crypto.hmac.digest( HMAC, c, key2, true ), "Corrupt DB" )

	local m = crypto.decrypt( Cipher, c, key, iv )

	return assert( json.decode( m ) )
end

local function writeDB( db, key )
	local iv = assert( urandom:read( IVLength ) )

	local m = assert( json.encode( db ) )
	local c = crypto.encrypt( Cipher, m, key, iv )

	local key2 = crypto.digest( Hash, key )
	local hmac = crypto.hmac.digest( HMAC, c, key2, true )

	local file = assert( io.open( paths.db, "w" ) )
	assert( file:write( iv .. c .. hmac ) )
	assert( file:close() )
end

local function genkey()
	local rfile = io.open( paths.key, "r" )
	check( not rfile, "You already have a private key." )

	print( "Generating your private key. Go do something else while we gather entropy." )

	local key = ""

	while key:len() < KeyLength do
		key = key .. assert( random:read( 1 ) )

		io.write( "\r" )
		for i = 1, 32 do
			io.write( i <= key:len() and ">" or "-" )
		end
		io.flush()
	end

	print( "\a" )

	local wfile = assert( io.open( dir .. "key", "w" ) )
	assert( wfile:write( key ) )
	assert( wfile:close() )

	print( "Done! You should chmod 700 ~/.pdb/key" )

	os.exit( 0 )
end

-- real code starts here

check( arg[ 1 ] and commands[ arg[ 1 ] ], Help )

lfs.mkdir( dir )

if arg[ 1 ] == "genkey" then
	local ok, err = pcall( genkey )

	check( ok, "genkey failed: %s", err )

	os.exit( 0 );
end

local ok_key, key = pcall( loadKey )
check( ok_key, "Couldn't private key: %s", key )

if arg[ 1 ] == "init" then
	local file = io.open( paths.db, "r" )
	check( not file, "You already have a password database." )

	local ok, err_write = pcall( writeDB, { }, key )
	check( ok, "Couldn't write database: %s", err_write )

	print( "Database initialised." )

	os.exit( 0 )
end

if arg[ 1 ] == "add" then
	check( arg[ 2 ], "add needs a password name." )

	io.stdout:write( "Enter a password for " .. arg[ 2 ] .. ": " )
	io.stdout:flush()

	passwordToAdd = assert( io.stdin:read( "*l" ) )

	check( passwordToAdd and passwordToAdd:len() > 0, "Nevermind." )
end

local ok_load, db = pcall( loadDB, key )
check( ok_load, "Couldn't load database: %s", db )

if arg[ 1 ] == "get" then
	check( arg[ 2 ], "get needs a password name." )

	if db[ arg[ 2 ] ] then
		print( db[ arg[ 2 ] ] )
	end
elseif arg[ 1 ] == "add" then
	check( not db[ arg[ 2 ] ], "%s is already in the database", arg[ 2 ] )

	db[ arg[ 2 ] ] = passwordToAdd
elseif arg[ 1 ] == "delete" then
	check( arg[ 2 ], "delete needs a password name." )

	db[ arg[ 2 ] ] = nil
elseif arg[ 1 ] == "list" then
	local passwords = { }

	for k in pairs( db ) do
		table.insert( passwords, k )
	end
	table.sort( passwords )

	for _, k in ipairs( passwords ) do
		print( k )
	end
elseif arg[ 1 ] == "gen" then
	check( not db[ arg[ 2 ] ], "%s is already in the database", arg[ 2 ] )

	local genLength = tonumber( arg[ 3 ] ) or 32
	local genPattern = "[" .. ( ( ( arg[ 3 ] and not tonumber( arg[ 3 ] ) ) and arg[ 3 ] ) or arg[ 4 ] or "%w%p " ) .. "]"

	-- matches is a list of characters that match genPattern
	-- chars is matches repeated to best fill 256 chars to
	-- accelerate generation of passwords from small charsets

	local matches = { }
	local chars = { }

	for i = 0, 255 do
		if string.char( i ):match( genPattern ) then
			table.insert( matches, string.char( i ) )
		end
	end

	for i = 1, math.floor( 256 / #matches ) * #matches do
		chars[ string.char( i - 1 ) ] = matches[ ( ( i - 1 ) % #matches ) + 1 ]
	end

	print( "Generating a password for " .. arg[ 2 ] .. ". Go do something else while we gather entropy." )

	local password = ""

	while password:len() < genLength do
		local c = random:read( 1 )

		if chars[ c ] then
			password = password .. chars[ c ]
		end

		io.write( "\r" )
		for i = 1, genLength do
			io.write( i <= password:len() and ">" or "-" )
		end
		io.flush()
	end

	print( "\a" )
	
	db[ arg[ 2 ] ] = password
end

local ok_write, err_write = pcall( writeDB, db, key )
check( ok_write, "Couldn't write database: %s", err_write )

assert( random:close() )
assert( urandom:close() )
